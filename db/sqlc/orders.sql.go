// Code generated by sqlc. DO NOT EDIT.
// source: orders.sql

package db

import (
	"context"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO  orders (
    total,
    subtotal,
    taxes,
    paid
) VALUES (
    $1, $2, $3, $4
) RETURNING id, name_id, id_unionop, total, subtotal, taxes, paid, created_at
`

type CreateOrderParams struct {
	Total    float64 `json:"total"`
	Subtotal float64 `json:"subtotal"`
	Taxes    string  `json:"taxes"`
	Paid     string  `json:"paid"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.queryRow(ctx, q.createOrderStmt, createOrder,
		arg.Total,
		arg.Subtotal,
		arg.Taxes,
		arg.Paid,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.NameID,
		&i.IDUnionop,
		&i.Total,
		&i.Subtotal,
		&i.Taxes,
		&i.Paid,
		&i.CreatedAt,
	)
	return i, err
}

const getOrder = `-- name: GetOrder :one
SELECT  id, name_id, id_unionop, total, subtotal, taxes, paid, created_at FROM orders
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetOrder(ctx context.Context, id int64) (Order, error) {
	row := q.queryRow(ctx, q.getOrderStmt, getOrder, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.NameID,
		&i.IDUnionop,
		&i.Total,
		&i.Subtotal,
		&i.Taxes,
		&i.Paid,
		&i.CreatedAt,
	)
	return i, err
}

const listOrder = `-- name: ListOrder :many
SELECT id, name_id, id_unionop, total, subtotal, taxes, paid, created_at FROM orders
ORDER BY id
LIMIT $1
`

func (q *Queries) ListOrder(ctx context.Context, limit int32) ([]Order, error) {
	rows, err := q.query(ctx, q.listOrderStmt, listOrder, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.NameID,
			&i.IDUnionop,
			&i.Total,
			&i.Subtotal,
			&i.Taxes,
			&i.Paid,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
